// SPDX-License-Identifier: Apache-2.0
// Licensed to the Ed-Fi Alliance under one or more agreements.
// The Ed-Fi Alliance licenses this file to you under the Apache License, Version 2.0.
// See the LICENSE and NOTICES files in the project root for more information.

using System;
using System.Globalization;
using System.Text.RegularExpressions;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;

namespace EdFi.Ods.Common.Serialization
{
    public class Iso8601UtcDateOnlyConverter : IsoDateTimeConverter
    {
        // All valid US English time formats will contain either a time separator ':' or an AM/PM designator
        private readonly Regex _timePortionRegex = new Regex(":|am|pm", RegexOptions.Compiled | RegexOptions.IgnoreCase);
        private const string OutputDateFormat = "yyyy-MM-dd";

        public override object ReadJson(JsonReader reader, Type objectType, object existingValue,
                                        JsonSerializer serializer)
        {
            if (reader.DateParseHandling != DateParseHandling.None)
            {
                throw new ApplicationException(
                    "This converter is only valid when used with DateParseHandling.None. " +
                    "This is due to the built in functionality of Json.Net forcing date parsing by default on " +
                    "any strings it finds that happen to match ISO8601 format. " +
                    "See https://github.com/JamesNK/Newtonsoft.Json/issues/862 for additional information.");
            }

            object result;

            string value = reader.Value.ToString();

            if (_timePortionRegex.IsMatch(value))
            {
                throw new FormatException("String was not recognized as a valid date.");
            }

            try
            {
                result = base.ReadJson(reader, objectType, existingValue, serializer);
            }
            catch (FormatException ex)
            {
                // Convert the message generated by a parsing error to indicate the value isn't a valid "date" (rather than "DateTime").
                throw new FormatException(ex.Message.Replace("DateTime", "date"), ex);
            }

            return result;
        }

        public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
        {
            // Reimplementing the base method to use our custom output format without setting `DateTimeFormat`
            // because ReadJson uses it (and we want to support all ISO8601 formats during reading).
            // Note that setting `DateTimeFormat` and restoring it after calling Write introduces a race condition.
            // The rest of this code is the default implementation and may need to update on version updates.
            // see https://github.com/JamesNK/Newtonsoft.Json/blob/13.0.2/Src/Newtonsoft.Json/Converters/IsoDateTimeConverter.cs#L79

            string text;

            if (value is DateTime dateTime)
            {
                if ((DateTimeStyles & DateTimeStyles.AdjustToUniversal) == DateTimeStyles.AdjustToUniversal
                    || (DateTimeStyles & DateTimeStyles.AssumeUniversal) == DateTimeStyles.AssumeUniversal)
                {
                    dateTime = dateTime.ToUniversalTime();
                }

                text = dateTime.ToString(OutputDateFormat, Culture);
            }
            else if (value is DateTimeOffset dateTimeOffset)
            {
                if ((DateTimeStyles & DateTimeStyles.AdjustToUniversal) == DateTimeStyles.AdjustToUniversal
                    || (DateTimeStyles & DateTimeStyles.AssumeUniversal) == DateTimeStyles.AssumeUniversal)
                {
                    dateTimeOffset = dateTimeOffset.ToUniversalTime();
                }

                text = dateTimeOffset.ToString(OutputDateFormat, Culture);
            }
            else
            {
                throw new JsonSerializationException("Unexpected value when converting date. Expected DateTime or DateTimeOffset");
            }

            writer.WriteValue(text);
        }
    }
}
