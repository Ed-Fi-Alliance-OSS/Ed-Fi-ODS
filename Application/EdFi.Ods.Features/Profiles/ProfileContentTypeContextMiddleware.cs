// SPDX-License-Identifier: Apache-2.0
// Licensed to the Ed-Fi Alliance under one or more agreements.
// The Ed-Fi Alliance licenses this file to you under the Apache License, Version 2.0.
// See the LICENSE and NOTICES files in the project root for more information.

using System;
using System.Linq;
using System.Threading.Tasks;
using EdFi.Ods.Api.Extensions;
using EdFi.Ods.Common.Context;
using EdFi.Ods.Common.Exceptions;
using EdFi.Ods.Common.Extensions;
using EdFi.Ods.Common.Logging;
using EdFi.Ods.Common.Metadata.Profiles;
using EdFi.Ods.Common.Profiles;
using EdFi.Ods.Common.Utils.Profiles;
using log4net;
using Microsoft.AspNetCore.Http;
using Microsoft.Extensions.Primitives;
using Microsoft.Net.Http.Headers;

namespace EdFi.Ods.Api.Middleware;

/// <summary>
/// Implements middleware that inspects the content type of a request (Accept for GET request, Content-Type for PUT/POST requests),
/// and initializes the <see cref="ProfileContentTypeContext" /> for the current request.
/// </summary>
public class ProfileContentTypeContextMiddleware
{
    private readonly ILogContextAccessor _logContextAccessor;
    private const string ProfileContentTypePrefix = "application/vnd.ed-fi.";

    // This unusual structure for log message format specifiers was introduced to avoid an invalid "critical" warning
    // generated by CodeQL for an "uncontrolled format string".
    private enum LogMessageFormatType
    {
        InvalidContentTypeHeaderFormat = 0,
        InvalidUsageTypeFormat,
        NonExistingProfileFormat,
        MisconfiguredProfileFormat,
    }

    // Array entries must correlate to the enum index values above.
    private readonly string[] _logMessageFormatSpecifiers = {
        // InvalidContentTypeHeaderFormat
        "The format of the profile-based '{0}' header was invalid.",

        // InvalidUsageTypeFormat
        "The profile usage segment in the profile-based '{0}' header was not recognized.",

        // NonExistingProfileFormat
        "The profile specified by the content type in the '{0}' header is not supported by this host.",

        // MisconfiguredProfileFormat
        "The profile specified by the content type in the '{0}' header is configured but invalid.",
    };

    private const int ResourceNameFacet = 0;
    private const int ProfileNameFacet = 1;
    private const int UsageFacet = 2;
    private readonly RequestDelegate _next;
    private readonly IProfileMetadataProvider _profileMetadataProvider;

    private readonly ILog _logger = LogManager.GetLogger(typeof(ProfileContentTypeContextMiddleware));

    public ProfileContentTypeContextMiddleware(RequestDelegate next, IProfileMetadataProvider profileMetadataProvider, ILogContextAccessor logContextAccessor)
    {
        _next = next;
        _profileMetadataProvider = profileMetadataProvider;
        _logContextAccessor = logContextAccessor;
    }

    public async Task InvokeAsync(
        HttpContext context,
        IContextProvider<ProfileContentTypeContext> profileContentTypeContextProvider)
    {
        if (context.Request.Method == HttpMethods.Get)
        {
            // Only process profile content types in the Accept header
            var profileContentType = context.Request.Headers.Accept.FirstOrDefault(ct => ct.StartsWith(ProfileContentTypePrefix));

            if (profileContentType != null)
            {
                LogicalThreadContext.Properties["ProfilesHeader"] = profileContentType;
                var (continueInvocation, profileContentTypeContext) = await TryProcessProfileContentTypeAsync(
                    "Accept",
                    profileContentType,
                    context.Response,
                    context.Request);

                if (!continueInvocation)
                {
                    return;
                }

                profileContentTypeContextProvider.Set(profileContentTypeContext);
            }
        }
        else if (context.Request.Method == HttpMethods.Post || context.Request.Method == HttpMethods.Put)
        {
            // Only process profile content types
            string profileContentType = context.Request.ContentType;

            if (profileContentType?.StartsWith(ProfileContentTypePrefix) ?? false)
            {
                LogicalThreadContext.Properties["ProfilesHeader"] = profileContentType;

                var (continueInvocation, profileContentTypeContext) = await TryProcessProfileContentTypeAsync(
                    "Content-Type",
                    profileContentType,
                    context.Response,
                    context.Request);

                if (!continueInvocation)
                {
                    return;
                }

                profileContentTypeContextProvider.Set(profileContentTypeContext);
            }
        }

        await _next(context);

        async Task<(bool continueInvocation, ProfileContentTypeContext profileContentTypeContext)> TryProcessProfileContentTypeAsync(
            string headerName,
            string contentType,
            HttpResponse response,
            HttpRequest request)
        {
            // e.g. application/vnd.ed-fi.student.test-profile.readable+json
            if (MediaTypeHeaderValue.TryParse(contentType, out var mt))
            {
                // Skip known existing segments for "vnd.ed-fi", and retrieve just the resource name, profile name and usage
                var profileContentTypeFacets = mt.Facets.Skip(2).ToArray();

                if (profileContentTypeFacets.Length != 3)
                {
                    await WriteResponseUsingFormat(response, StatusCodes.Status400BadRequest, headerName, LogMessageFormatType.InvalidContentTypeHeaderFormat);

                    return (false, null);
                }

                if (!TryGetContentTypeUsage(profileContentTypeFacets[UsageFacet], out var contentTypeUsage))
                {
                    await WriteResponseUsingFormat(response, StatusCodes.Status400BadRequest, headerName, LogMessageFormatType.InvalidUsageTypeFormat);

                    return (false, null);
                }

                // Validate that the usage type matches the request method
                if (contentTypeUsage == ContentTypeUsage.Writable && request.Method == HttpMethods.Get)
                {
                    await WriteResponseMessage(
                        response,
                        StatusCodes.Status400BadRequest,
                        "A profile-based content type that is writable cannot be used with GET requests.");

                    return (false, null);
                }

                if (contentTypeUsage == ContentTypeUsage.Readable
                    && (request.Method == HttpMethods.Post || request.Method == HttpMethods.Put))
                {
                    await WriteResponseMessage(
                        response,
                        StatusCodes.Status400BadRequest,
                        $"A profile-based content type that is readable cannot be used with {request.Method.ToUpper()} requests.");

                    return (false, null);
                }

                // Validate that the Profile exists and is valid
                string profileName = profileContentTypeFacets[ProfileNameFacet].Value;

                if (_profileMetadataProvider.GetValidationResults().Any(x => x.Name.Equals(profileName, StringComparison.OrdinalIgnoreCase)))
                {
                    await WriteResponseUsingFormat(
                        response,
                        StatusCodes.Status406NotAcceptable,
                        headerName,
                        LogMessageFormatType.MisconfiguredProfileFormat);

                    return (false, null);
                }
                
                if (!_profileMetadataProvider.ProfileDefinitionsByName.ContainsKey(profileName))
                {
                    await WriteResponseUsingFormat(
                        response,
                        request.Method == HttpMethods.Get
                            ? StatusCodes.Status406NotAcceptable
                            : StatusCodes.Status415UnsupportedMediaType,
                        headerName,
                        LogMessageFormatType.NonExistingProfileFormat);

                    return (false, null);
                }

                var profileContentTypeContext = new ProfileContentTypeContext(
                    profileName,
                    profileContentTypeFacets[ResourceNameFacet].Value,
                    contentTypeUsage);

                return (true, profileContentTypeContext);
            }

            return (true, null);
        }

        Task WriteResponseUsingFormat(
            HttpResponse response,
            int statusCode,
            string headerName,
            LogMessageFormatType logMessageFormatType)
        {
            string correlationId = _logContextAccessor.GetCorrelationId();
            string errorMessage = string.Format(_logMessageFormatSpecifiers[(int)logMessageFormatType], headerName);
            
            _logger.Error(errorMessage);
            
            return response.WriteProblemDetailsAsync(
                statusCode,
                ProfileContentTypeUsageException.TitleText,
                ProfileContentTypeUsageException.DefaultDetail,
                new[] { errorMessage },
                correlationId,
                ProfileContentTypeUsageException.TypePart);
        }

        Task WriteResponseMessage(HttpResponse response, int statusCode, string errorMessage)
        {
            string correlationId = _logContextAccessor.GetCorrelationId();
            
            _logger.Error(errorMessage);
            
            return response.WriteProblemDetailsAsync(
                statusCode,
                ProfileContentTypeUsageException.TitleText,
                ProfileContentTypeUsageException.DefaultDetail,
                new[] { errorMessage },
                correlationId,
                ProfileContentTypeUsageException.TypePart);
        }

        bool TryGetContentTypeUsage(StringSegment profileContentTypeFacet, out ContentTypeUsage contentTypeUsage)
        {
            var usageSegment = profileContentTypeFacet;

            if (usageSegment.Equals("readable", StringComparison.OrdinalIgnoreCase))
            {
                contentTypeUsage = ContentTypeUsage.Readable;

                return true;
            }

            if (usageSegment.Equals("writable", StringComparison.OrdinalIgnoreCase))
            {
                contentTypeUsage = ContentTypeUsage.Writable;

                return true;
            }

            contentTypeUsage = default;

            return false;
        }
    }
}
